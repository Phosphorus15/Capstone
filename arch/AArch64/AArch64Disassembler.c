//===- AArch64Disassembler.cpp - Disassembler for AArch64 ISA -------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the functions necessary to decode AArch64 instruction
// bitpatterns into MCInsts (with the help of TableGenerated information from
// the instruction definitions).
//
//===----------------------------------------------------------------------===//

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */

#ifdef CAPSTONE_HAS_ARM64

#include <stdio.h>	// DEBUG
#include <stdlib.h>

#include "../../cs_priv.h"
#include "../../utils.h"

#include "AArch64Disassembler.h"

#include "../../MCDisassembler.h"
#include "../../MCFixedLenDisassembler.h"
#include "../../MCInst.h"
#include "../../MCInstrDesc.h"
#include "../../MCRegisterInfo.h"

#include "AArch64AddressingModes.h"
#include "AArch64BaseInfo.h"

// Forward declare these because the autogenerated code will reference them.
// Definitions are further down.

static bool Check(DecodeStatus *Out, DecodeStatus In)
{
	switch (In) {
		default:	// never reach
			return true;

		case MCDisassembler_Success:
			// Out stays the same.
			return true;

		case MCDisassembler_SoftFail:
			*Out = In;
			return true;

		case MCDisassembler_Fail:
			*Out = In;
			return false;
	}
	// llvm_unreachable("Invalid DecodeStatus!");
}

// Hacky: enable all features for disassembler
uint64_t AArch64_getFeatureBits(int feature)
{
	// enable all features
	return (uint64_t)-1;
}

#define Success MCDisassembler_Success
#define Fail MCDisassembler_Fail
#define SoftFail MCDisassembler_SoftFail

#define GET_SUBTARGETINFO_ENUM
#include "AArch64GenSubtargetInfo.inc"
#include "CapstoneAArch64Module.h"

static DecodeStatus _getInstruction(cs_struct *ud, MCInst *MI,
		const uint8_t *code, size_t code_len,
		uint16_t *Size,
		uint64_t Address, MCRegisterInfo *MRI)
{
	uint32_t insn;
	DecodeStatus result;
	size_t i;

	if (code_len < 4) {
		// not enough data
		*Size = 0;
		return MCDisassembler_Fail;
	}

	if (MI->flat_insn->detail) {
		memset(MI->flat_insn->detail, 0, offsetof(cs_detail, arm64)+sizeof(cs_arm64));
		for (i = 0; i < ARR_SIZE(MI->flat_insn->detail->arm64.operands); i++)
			MI->flat_insn->detail->arm64.operands[i].vector_index = -1;
	}

	if (MODE_IS_BIG_ENDIAN(ud->mode))
		insn = (code[3] << 0) | (code[2] << 8) |
			(code[1] <<  16) | ((uint32_t) code[0] << 24);
	else
		insn = ((uint32_t) code[3] << 24) | (code[2] << 16) |
			(code[1] <<  8) | (code[0] <<  0);

	// Calling the auto-generated decoder function.
	result = decodeInstruction_4(DecoderTable32, MI, insn, Address, 0, 0);
	if (result != MCDisassembler_Fail) {
		*Size = 4;

		return result;
	}

	// invalid code
	MCInst_clear(MI);
	*Size = 0;

	return MCDisassembler_Fail;
}

bool AArch64_getInstruction(csh ud, const uint8_t *code, size_t code_len,
		MCInst *instr, uint16_t *size, uint64_t address, void *info)
{
	DecodeStatus status = _getInstruction((cs_struct *)ud, instr,
			code, code_len,
			size,
			address, (MCRegisterInfo *)info);

	return status == MCDisassembler_Success;
}

void AArch64_init(MCRegisterInfo *MRI)
{
	/*
	   InitMCRegisterInfo(AArch64RegDesc, 661,
	   		RA, PC,
			AArch64MCRegisterClasses, 100,
			AArch64RegUnitRoots, 115, AArch64RegDiffLists,
			AArch64LaneMaskLists, AArch64RegStrings, AArch64RegClassStrings,
			AArch64SubRegIdxLists, 100,
			AArch64SubRegIdxRanges, AArch64RegEncodingTable);
	*/

	MCRegisterInfo_InitMCRegisterInfo(MRI, AArch64RegDesc, 661,
			0, 0,
			AArch64MCRegisterClasses, 100,
			0, 0, AArch64RegDiffLists,
			0,
			AArch64SubRegIdxLists, 100,
			0);
}

#endif
